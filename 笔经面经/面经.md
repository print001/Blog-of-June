## 百度（3轮技术面+1轮HR） 
### 1  cookie和session, cookie和webStorage的区别，如果cookie被篡改怎么办
    答：cookie是客户端的状态保持方案。cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这
    个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。
    session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
       考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
       考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
    webstorage 是HTML5引入的客户端存储方式。
    能够对浏览器使用事件钩子，例如offline，online，storage change
    比cookies更便于管理，没有额外的的请求头部数据
    提供更大的空间以存贮日益剧增的复杂数据
### 2 跨域的方法
    什么是跨域：当协议、子域名、主域名、端口号中任意一各不相同时，都算不同的“域”。
    1、JSONP 以下是实现方法
    //创建一个script元素
    var  Scr = document.reateElement('script');
    //声明类型
    Scr.type='text/javascript';
    //添加src属性，引入跨域访问的url
    Scr.src='http://www.b.com/gerinfo.php';
    //在页面中添加新创建的script元素
    document.getElementsByTagName('head')[0].appendChild(Scr)
    2、跨域资源共享（CORS）
    3、代理：通过后台(ASP、PHP、JAVA、ASP.NET)获取其他域名下的内容，然后再把获得内容返回到前端
    4、处理跨域的方法3 -- XHR2 （H5）
    * IE10以下的版本都不支持
    * 只需要在服务器端头部加上下面两句代码：
    header( "Access-Control-Allow-Origin:*" );
    header( "Access-Control-Allow-Methods:POST,GET" );
### 3 因为引用计数产生的内存泄漏，在ES6中的解决办法是什么
    es6 中的let命令 用来声明块级变量 不存在函数声明提升
### 4 js中基本类型在内存中存储方式是什么，引用类型的存储方式是什么
    在JavaScript中变量包含两种不同数据类型的值，一种是基本类型值，
    一种是引用类型值。基本类型值是指那种数据值可以完全保存在栈内存
    中的简单数据片段，包括Undefined，Null，String，Boolean和Number，
    因为这些数据类型的值在内存中所占空间大小是固定的，而引用类型值都是
    Object的实例，包括Object,Array等等，这些值由于大小不固定所以先
    保存在堆内存中，然后将保存这些对象的内存地址保存到栈内存中，
    因为内存地址的大小固定的。
    栈：先进后出的数据结构，是系统提供的功能，大小有限制，
    堆：先进先出，大小可控
### 5 手写jsonp以及常见的响应码，特别问了401
    手写见2 常见的响应码：
    见w3cschool :200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500
### 6 渐进增强和优雅降级 
    渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高
    级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。关注内容本身
    优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
    针对那些最高级、最完善的浏览器来设计网站
### 7 封装的js插件，事件委托和性能优化 
    用立即执行函数(匿名函数)，封装js插件 对与ES6 使用module对插件封装
    事件委托：事件委托是通过事件冒泡的原理，利用父级去触发子级的事件
    好处:不用重复绑定多个事件，原生写法
    _wrap.addEventListener('click', function(ev){
     var ev = ev || event; 
     if( ev.target.nodeName == 'LI' ) {
      ev.target.style.background = '#8EC0E4'; 
      console.log( ev.target.innerHTML ); } // 找到父级 ul#wrap
       this.style.border = '2px solid #f00'; }); 
    $('#wrap').on('click', 'li', function(ev) { // this 指向委托的对象 li 
    $(this).css('background', '#D4DFE6'); // 找到父级 ul#wrap $(ev.delegateTarget).css('border', '2px solid #f00'); }) 
    性能优化：1、减少http请求，合理设置 HTTP缓存
             2、使用浏览器缓存
             3、启用压缩
             4、CSS Sprites合并 CSS图片，减少请求数的又一个好办法。
             5、LazyLoad Images
             6、CSS放在页面最上部，javascript放在页面最下面
             7、减少cookie传输
             8、异步请求Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）
             9、减少cookie传输
             10、减少DOM操作
### 8 http连接性能优化，长连接，keep-alive 
    1、服务器端：关闭KeepAlive。
    2、服务器端：最好直接支持HTTP协议（注意用POST，不要GET）,而不是任何包装过的协议，比如：hessian/soap等。
    3、服务器端：在一个请求中，最好设计成：支持多条指令批处理，以节省连接数。
    4、服务器端：对请求的处理应当尽可能的快（如在150ms内）。
    5、客户端：在代码中，同一个客户端实例中全部请求结束后应主动关闭连接（无须事先设置客户端的ConnectionTimeOut参数）。
    6、客户端：如服务器未关闭KeepAlive，在同一个客户端实例中可以适量发出多个请求（总时间应稍小于服务器KeepAliveTimeout参数）。此方式需要精确操作，不推荐。
    最后，在接口设计上，对于一些异步操作，尽量不要设计成单方面轮询模式（减少大量无谓请求数），应设计成被调用方的异步
    结果回调模式。 
### 9 从输入url到看到页面发生了什么 
    DNS解析：浏览器缓存->系统缓存->路由器缓存->ISP DNS缓存->递归搜索
    TCP连接：浏览器最终得到了解析后的IP，并尝试用这个IP和服务器在三次握手后建立一个TCP连接
    发送HTTP请求：
    服务器处理请求并返回HTTP报文
    浏览器解析渲染页面：浏览器接收到HTTP响应，关闭TCP连接； HTML解析出DOM Tree->CSS解析出Style Rules->将二者关联生成Render Tree
    ->Layout 根据Render Tree计算每个节点的信息->Painting 根据计算好的信息绘制整个页面 
### 10 前端缓存机制，如果去掉etags\last-modefied\cache-control这些控制缓存的字段，浏览器会怎么处理缓存     
     1、cache-control和expires
     Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是
     重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。
     2、etags和last-modefied
     配置Last-Modified/ETag的情况下，浏览器再次访问统一URI的资源，还是会发送请求到服务器询问文件是否已经修改，
     如果没有，服务器会只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新
     发给浏览器；
### 11 说一下前端性能优化的各种情况，然后讲清楚每一个类别的细节 
    同 7
### 12 关于vue组件生命周期，传送数据在哪个周期发生
### 13 给你一个团队，怎么去带，怎么分配任务和把控项目进度 
### 14 设计一个产品，实现非前端人员或者运维人员可以方便使用，达到不需要专业前端开发人员就可以实现前端交互实现的功能，
### 详细介绍产品设计的思路、技术选型、用户体验考虑、前端底层支撑实现、项目架构设计和后台架构设计。
### 15 let暂时性死区和块级作用域
    let定义的变量只在代码块{}内有效，let实际上为JavaScript新增了块级作用域。和var的区别是不存在变量提升，
    不允许重复声明；
    暂时性死区：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
### 16 实现深拷贝
    深拷贝和浅拷贝：浅复制只复制一层对象的属性，复制属性地址，而深复制则递归复制了所有层级。
    var y = $.extend({}, x),          //shallow copy
       z = $.extend(true, {}, x);    //deep copy
### 17 前端安全（XSS、CSRF以及应对措施）
    XSS（cross-site scripting跨域脚本攻击）攻击是最常见的Web攻击，其重点是“跨域”和“客户端执行”。有人将XSS攻击分为三种，分别是：
    1. Reflected XSS（基于反射的XSS攻击）
    2. Stored XSS（基于存储的XSS攻击）
    3. DOM-based or local XSS（基于DOM或本地的XSS攻击）
### 18 类数组有哪些 
    arguements,nodeList
### 19 for in的缺点
       for in能访问可遍历的，实例和原型中的属性
### 20 forEach()
    对数组中的没一项运行给定函数，没有返回值 
### 21 ES6中map遍历的实现原理
    map遍历方法有：keys(),values(),entries(),forEach()
    遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。
    任何数据结构只要部署Iterator接口(next()方法)，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
### 22  数组去重问题
    1、数组下标法
    2、对象键值法去重速度最快， 占空间最多（空间换时间）：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，
    不是的话给对象新增该键并放入新数组。
    3、简单数组去重法：新建一新数组，遍历传入数组，值不在新数组就push进该新数组中
    4、优化遍历数组法：获取重复的最右一值放入新数组。检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断
    
### 23 React(Vue)的思想和原理，虚拟DOM树和diff算法     
## 美团（3轮技术面+1轮HR） 
### 1、https的详细过程，使用的加密算法，是对称加密算法还是非对称加密算法。md5、SHA、AES分别是对称加密的还是非对称加密的             
    
    